/** @file
 *	@brief	Clock system service implementation for PIC32 MZ devices.
 *
 *	Description:
 *	This file Implements the functions specific to PIC32 MZ devices.
 *
 *
 *	@note	This file is an as-needed COPY of the file created by Microchip's Harmony Configurator,
 *	v2.04, and/or the tool-created support files (e.g., Peripheral Libs) supplied as part of the
 *	MHC eco system. We have NO intention of stealing code or technology, or of claiming undue
 *	credit. This file is here ONLY during the buildup of support for the PIC32 MZ2048 EFM 144
 *	Starter Kit, what we call the "MZ EZ" board. Eventually, I hope to link directly to Harmony's
 *	code, in a way that allows different target architectures
 *
 *	Anyway, because this is a copy of code generated by a tool owned by Microchip, there is
 *	attribution here but no copyright notice.
 *
 *
 *	Original:
 *	Created on: Dec 27, 2017
 *	Author: kbecker
 *
 *	Current:
 *	$Revision: $
 *	$Date: $
 */

// ============================================================================
// ----	Include Files ---------------------------------------------------------
// ============================================================================

#include "projcfg.h"

#if (USE_SYS_CLK == true)			/* { */

// ----	System Headers --------------------------
#include <stddef.h>
#include <stdlib.h>

// ----	Project Headers -------------------------
#include "cwsw_lib.h"
#include "system/system_config.h"

#include "system/system_config.h"
#include "system/clk/src/osc_OscSelect_none.h"
#include "system/clk/src/sys_clk_local.h"
#include "system/devcon/sys_devcon.h"


// ============================================================================
// ----	Constants -------------------------------------------------------------
// ============================================================================

// ============================================================================
// ----	Type Definitions ------------------------------------------------------
// ============================================================================

// ============================================================================
// ----	Global Variables ------------------------------------------------------
// ============================================================================

// ============================================================================
// ----	Module-level Variables ------------------------------------------------
// ============================================================================

// ============================================================================
// ----	Private Prototypes ----------------------------------------------------
// ============================================================================

// ============================================================================
// ----	Public Functions ------------------------------------------------------
// ============================================================================

/******************************************************************************
  Function:
    OSC_PERIPHERAL_BUS _SYS_CLK_GetOscPeripheralBus ( CLK_BUSES_REFERENCE peripheralBus )

  Summary:
    Helper function to remap peripheral bus enums to PLIB OSC enums

  Description:
    Helper function to remap peripheral bus enums to PLIB OSC enums

  Remarks:
    None.
*/
OSC_PERIPHERAL_BUS _SYS_CLK_GetOscPeripheralBus ( CLK_BUSES_PERIPHERAL peripheralBus )
{
    OSC_PERIPHERAL_BUS oscBus = (OSC_PERIPHERAL_BUS)peripheralBus;

    return oscBus;
}

/******************************************************************************
  Function:
    unsigned int SYS_CLK_SystemClockSet ( SYS_CLK_SOURCE clockSource,
                                            unsigned long clockFrequency )
  Summary:
    Sets the clock source and frequency for the system clock.

  Description:
    This function sets the clock frequency and source for the system clock.

  Remarks:
    None.
*/
#include "osc/plib_osc.h"		/* PLIB_OSC_SysPLLInputClockSourceGet() */
bool
_SYS_CLK_SystemClockSet(
		CLK_SOURCES_SYSTEM systemSource,
		uint32_t systemClockHz,
		bool waitUntilComplete,
		uint32_t *clockClosest)
{
//    unsigned char calculatedRegValue = 0, valueToPLLMULT = 0, valueToPLLODIV = 0;
    unsigned long achievedFreq = 0;
//    int8_t result;

    UNUSED(systemSource);
    UNUSED(waitUntilComplete);
    UNUSED(clockClosest);

//    switch ( systemSource )
//    {
//        case SYS_CLK_SOURCE_FRC_BY_DIV:
//            /* As we know the output and input frequencies, get the multiplier
//            needed to get the output */
//            calculatedRegValue = TO_U8( SYS_CLK_FRC_CLOCK / systemClockHz );
//
//            /* Find the closest register value in the hardware */
//            achievedFreq = SYS_CLK_FRCClosestDivisorGet ( calculatedRegValue, &valueToPLLMULT, systemClockHz );
//            break;
//
//        case SYS_CLK_SOURCE_LPRC:
//            /* Processor's internal LPRC clock */
//            achievedFreq = SYS_CLK_LPRC_CLOCK;
//            systemClockHz = achievedFreq;
//            break;
//
//        case SYS_CLK_SOURCE_SECONDARY:
//            achievedFreq = SYS_CLK_CONFIG_SECONDARY_XTAL;
//            systemClockHz = achievedFreq;
//            break;
//
//        case SYS_CLK_SOURCE_PRIMARY:
//            /* If the System clock is directly using the from the Primary oscillator
//            clock, return the configured primary oscillator frequency */
//            achievedFreq = SYS_CLK_CONFIG_PRIMARY_XTAL;
//            systemClockHz = achievedFreq;
//            break;
//
//        case SYS_CLK_SOURCE_FRC_SYSPLL:
//
//            if( OSC_SYSPLL_IN_CLK_SOURCE_FRC == PLIB_OSC_SysPLLInputClockSourceGet( OSC_PLIB_ID ))
//            {
//                /* Source of system clock is internal fast RC with PLL.
//                 Find the closest register value in the hardware */
//                achievedFreq = SYS_CLK_ClosestFactorsGet ( SYS_CLK_FRC_CLOCK,
//                        systemClockHz, &valueToPLLMULT, &valueToPLLODIV );
//            }
//            else
//            {
//                achievedFreq = SYS_CLK_ClosestFactorsGet ( SYS_CLK_CONFIG_PRIMARY_XTAL,
//                        systemClockHz, &valueToPLLMULT, &valueToPLLODIV );
//            }
//            break;
//
//        default:
//            return false;
//            break;
//    }
    /* Check whether the difference between the achievable frequency and the
    frequency requested is within the allowed range */
    if ( true == SYS_CLK_FrequencyErrorCheck ( systemClockHz, achievedFreq ) )
    {
//        result = SYS_CLK_SystemClockSourceSwitch ( systemSource, valueToPLLMULT,
//                    valueToPLLODIV, waitUntilComplete );
//
//        /* Update the new clock source and clock frequency for the system
//        clock */
//        if ( result == -1 )
//        {
//            clkObject.systemClockStatus = SYS_CLK_OPERATION_FAIL_SWITCHING_DISABLED;
//            return false;
//        }
//
//        /* Update the clock source and frequency */
//        clkObject.systemClockSource = result;
//        clkObject.systemClock = achievedFreq;
//        clkObject.systemClosestClock = achievedFreq;
    }
    else
    {
//        /* Requested frequency is not achievable. Update the error code and closest
//        possible frequency */
//        clkObject.systemClosestClock = achievedFreq;
//        clkObject.systemClockStatus = SYS_CLK_OPERATION_FAIL_NOT_ACHIEVABLE;
//        return false;
    }

    /* Control is here, means switching operation is either complete or in
    progress, not failure */
    return true;
}

CLK_SOURCES_SYSTEM
_SYS_CLK_ClockTypeMap( OSC_SYS_TYPE systemSource )
{
    switch( systemSource )
    {
        case OSC_FRC_WITH_PLL:
            return SYS_CLK_SOURCE_FRC_SYSPLL;
        case OSC_PRIMARY:
            return SYS_CLK_SOURCE_PRIMARY;
        case OSC_PRIMARY_WITH_PLL:
            return SYS_CLK_SOURCE_PRIMARY_SYSPLL;
        case OSC_SECONDARY:
            return SYS_CLK_SOURCE_SECONDARY;
        case OSC_LPRC:
            return SYS_CLK_SOURCE_LPRC;
        case OSC_FRC_BY_FRCDIV:
            return SYS_CLK_SOURCE_FRC_BY_DIV;
        case OSC_BFRC:
            return SYS_CLK_SOURCE_BKP_FRC;
        default:
            return SYS_CLK_SOURCE_NONE;
    }
}

OSC_SYS_TYPE _SYS_CLK_ClockSourceMap (CLK_SOURCES_SYSTEM clockSource)
{
	switch(clockSource)
	{
		case SYS_CLK_SOURCE_FRC_SYSPLL:
			return OSC_FRC_WITH_PLL;
		case SYS_CLK_SOURCE_PRIMARY:
			return OSC_PRIMARY;
		case SYS_CLK_SOURCE_PRIMARY_SYSPLL:
			return OSC_PRIMARY_WITH_PLL;
		case SYS_CLK_SOURCE_SECONDARY:
			return OSC_SECONDARY;
		case SYS_CLK_SOURCE_LPRC:
			return OSC_LPRC;
        case SYS_CLK_SOURCE_BKP_FRC:
            return OSC_BFRC;
		case SYS_CLK_SOURCE_FRC_BY_16:
			return OSC_FRC_BY_FRCDIV;
		case SYS_CLK_SOURCE_FRC_BY_DIV:
			return OSC_FRC_BY_FRCDIV;
		default:
			return 0xff;
	}

}

/******************************************************************************
  Function:
    uint32_t _SYS_CLK_PLLInputDividerRead ( void )

  Summary:
    Reads the value of the PLL Input Divider.

  Description:
    This function will read from the configuration the current value for the
    PLL Input Divider.  The value is translated from the configuration bit into
 *  the intended divider value.

  Remarks:
    None.
*/
uint32_t _SYS_CLK_PLLInputDividerRead ( void )
{
    return TO_U32(PLIB_OSC_SysPLLInputDivisorGet(OSC_PLIB_ID) + 1);
}


#error here
/******************************************************************************
  Function:
    uint32_t _SYS_CLK_SystemClockRead ( void )
  Summary:
    Gets the system clock from the hardware.

  Description:
    This function gets the System clock frequency from the hardware by using
    register reads.

  Remarks:
    None.
*/
uint32_t
_SYS_CLK_SystemClockRead(void)
{
//	CLK_SOURCES_SYSTEM systemSource;
//	uint32_t pllInputDiv = 0;
    uint32_t systemClockHz = 0 /*, multiplier = 0, divisor = 0, pllInput = 0*/;

    /* Read the current system clock source from the register */
//    systemSource = _SYS_CLK_ClockTypeMap(PLIB_OSC_CurrentSysClockGet ( OSC_PLIB_ID ));

    /* we need the source later for other clocks  */
//    clkObject.systemClockSource = systemSource;
//    switch ( systemSource )
//    {
//        case SYS_CLK_SOURCE_FRC_BY_DIV:
//            /* System clock is FRC clock divided by the configured diviso value */
//            divisor = PLIB_OSC_FRCDivisorGet ( OSC_PLIB_ID );
//
//            /* FRC clock is a constant. Do direct division */
//            systemClockHz = ( SYS_CLK_FRC_CLOCK / divisor );
//            break;
//
//        case SYS_CLK_SOURCE_FRC_SYSPLL:
//
//			pllInputDiv = _SYS_CLK_PLLInputDividerRead();
//
//			/* Check if the source is a PLL based one, validate the input frequency */
//            pllInput = SYS_CLK_FRC_CLOCK / pllInputDiv;
//
//			if ( pllInput > OSC_SYSPLL_RANGE_MAX )
//            {
//                clkObject.systemClockStatus = SYS_CLK_PLL_INVALID_INP_FREQUENCY;
//                systemClockHz = 0;
//            }
//            else
//            {
//                /* Source of system clock is internal fast RC with PLL and divisors */
//                multiplier = _SYS_CLK_PLLMultiplierRead();
//                divisor = _SYS_CLK_PLLOutputDividerRead();
//
//                systemClockHz = ( SYS_CLK_FRC_CLOCK * multiplier ) /
//                                ( divisor * pllInputDiv );
//            }
//
//            break;
//
//        /* Source of system clock is primary oscillator */
//        case SYS_CLK_SOURCE_PRIMARY:
//            /* If the System clock is directly using the from the Primary oscillator
//            clock, return the configured primary oscillator frequency */
//            systemClockHz = SYS_CLK_CONFIG_PRIMARY_XTAL;
//            break;
//
//        case SYS_CLK_SOURCE_PRIMARY_SYSPLL:
//
//			pllInputDiv = _SYS_CLK_PLLInputDividerRead();
//
//			/* Check if the source is a PLL based one, validate the input frequency */
//            pllInput = SYS_CLK_CONFIG_PRIMARY_XTAL / pllInputDiv;
//
//			if ( pllInput > OSC_SYSPLL_RANGE_MAX )
//            {
//                clkObject.systemClockStatus = SYS_CLK_PLL_INVALID_INP_FREQUENCY;
//                systemClockHz = 0;
//            }
//            {
//                /* Source of system clock is primary oscillator multiplied by
//                the PLL value and divided by the divisor configured by software.
//                Software cannot access the input divisor, so that must be configured
//                by the user */
//                multiplier = _SYS_CLK_PLLMultiplierRead();
//                divisor = _SYS_CLK_PLLOutputDividerRead();
//
//                systemClockHz = ( SYS_CLK_CONFIG_PRIMARY_XTAL * multiplier ) /
//                                ( divisor * pllInputDiv );
//            }
//            break;
//
//        case SYS_CLK_SOURCE_SECONDARY:
//            /* System clock is processor's Secondary oscillator. The secondary
//               oscillator frequency is user configured */
//            systemClockHz = SYS_CLK_CONFIG_SECONDARY_XTAL;
//            break;
//
//        case SYS_CLK_SOURCE_LPRC:
//            /* System clock is processor's internal LPRC clock */
//            systemClockHz = SYS_CLK_LPRC_CLOCK;
//            break;
//
//        case SYS_CLK_SOURCE_BKP_FRC:
//
//            systemClockHz = SYS_CLK_FRC_CLOCK;
//            break;
//
//        default:
//            /* Something wrong */
//            systemClockHz = 0;
//            break;
//    }

    return systemClockHz;
}

/******************************************************************************
  Function:
    unsigned long SYS_CLK_ClosestFactorsGet(    unsigned long sourceFrequency,
                                                unsigned long requestedFrequency,
                                                unsigned char *valueToReg1,
                                                unsigned char *valueToReg2 )

  Summary:
    Gets the value of the multiplier and divisor which is closest to the
    expected value for the system PLL.

  Description:
    This function gets the value of the multiplier and divisor which is closest
    to the expected value for the system PLL.

  Remarks:
    None.
*/
#include <limits.h>		/* klb: so i can silence compiler @ end of function SYS_CLK_ClosestFactorsGet() */
unsigned long
SYS_CLK_ClosestFactorsGet(
		unsigned long sourceFrequency, unsigned long requestedFrequency,
		unsigned char *valueToPLLMULT, unsigned char *valueToPLLODIV)
{
	uint8_t multCount = 0, divCount = 0;
	uint16_t multiplier = 0, divisor = 0;
	uint32_t inputDivisor = 0;
	unsigned long tempFrequency = 0;

	inputDivisor = _SYS_CLK_PLLInputDividerRead();

	for(multCount = 1; multCount <= 128; ++multCount)
	{
		multiplier = multCount;

		for(divCount = 0; divCount <= 5; ++divCount)
		{
			/* Implementation unique to MZ chip family */
			if(divCount == 0)
			{
				divCount++;
			}

			divisor = TO_U16(0x01U << divCount);	/* klb: silence compiler */

			tempFrequency = (sourceFrequency / inputDivisor) * multiplier / divisor;

			if((abs(TO_INT(requestedFrequency) - TO_INT(tempFrequency))) <= SYS_CLK_CONFIG_FREQ_ERROR_LIMIT)
			{
				*valueToPLLMULT = TO_U8(multiplier);	/* klb: silence compiler. is the data loss an issue? */
				*valueToPLLODIV = divCount;
				return tempFrequency;
			}
		}
	}

	return ULONG_MAX;		/* klb: silence compiler */
}


/******************************************************************************
  Function:
   char SYS_CLK_FRCClosestDivisorGet( unsigned char regValue,
                                                    unsigned char *valueToReg )

  Summary:
    Gets the value of the FRC clock divisor which is closest to the
    expected value.
.
  Description:
    This function gets the value of the FRC clock divisor which is
    closest to the expected value.

  Remarks:
    None.
*/

uint32_t
SYS_CLK_FRCClosestDivisorGet(unsigned char regValue, unsigned char *valueToReg, uint32_t requestedFrequency)
{
	uint8_t index = 0;
	uint16_t divisor = 0;
	uint32_t tempFrequency = 0, PrevFrequency = 0;

	UNUSED(regValue);

	for(index = 0; index < 8; index++)
	{
		divisor = index;
		/* Here the code is too specific to PIC32MX. The code may not be so easily
		 usable for other controllers. But seems like this is the best way to avoid
		 RAM usage for lookup tables */
		if(divisor == 7)
		{
			divisor++;
		}

		tempFrequency = TO_U32(SYS_CLK_FRC_CLOCK / ( 0x01 << divisor ));

		if((abs(TO_INT(requestedFrequency) - TO_INT(tempFrequency))) < (abs(TO_INT(requestedFrequency) - TO_INT(PrevFrequency))))
		{
			PrevFrequency = tempFrequency;
			*valueToReg = index;
		}
	}
	return PrevFrequency;
}

/******************************************************************************
  Function:
    bool SYS_CLK_FrequencyErrorCheck( unsigned long inpFreq,
                                        unsigned long acheivedFreq )
  Summary:
    Checks whether the difference between the user requested clock rate and
    the maximum achievable clock is within limit.

  Description:
    This function checks whether the difference between the user requested clock
    rate and the maximum achievable clock is within limit.
   		true - The difference between clocks is within limit.
		false - The difference between clocks is not within limit.

  Remarks:
    None.
*/
bool
SYS_CLK_FrequencyErrorCheck(unsigned long inpFreq, unsigned long acheivedFreq)
{
    /* Get the difference between frequency requested and achieved  */
    if(abs(TO_INT(inpFreq) - TO_INT(acheivedFreq)) > SYS_CLK_CONFIG_FREQ_ERROR_LIMIT)
    {
        return false;
    }
    return true;
}


/******************************************************************************
  Function:
    void SYS_CLK_SystemClockSourceSwitch ( SYS_CLK_SOURCE clockSource )

  Summary:
    Initiates the clock switch for the system clock.

  Description:
    This function initiates the clock switch for the system clock.

  Remarks:
    None.
*/
int8_t SYS_CLK_SystemClockSourceSwitch(CLK_SOURCES_SYSTEM clockSource, unsigned char valueToPLLMULT, unsigned char valueToPLLODIV, bool waitUntilComplete ) {
    uint32_t delay= 100;
    OSC_SYS_TYPE oscSource = _SYS_CLK_ClockSourceMap(clockSource);

    /* Check whether PLL and clock selections are locked */
    if( PLIB_OSC_PLLClockIsLocked ( OSC_PLIB_ID ) != true )
    {
        /* Unlock before you switch */
        SYS_DEVCON_SystemUnlock ( );

        /* Special treatment if the source is a PLL based source. Do not change
        multipliers after switching. Switch to a FRC source first, then alter
        the multiplier values. */
        if ( ( ( clockSource == SYS_CLK_SOURCE_PRIMARY_SYSPLL ) ) ||
            ( clockSource == SYS_CLK_SOURCE_FRC_SYSPLL ) )
        {
            PLIB_OSC_SysClockSelect( OSC_PLIB_ID, OSC_FRC_BY_FRCDIV );

            /* Ensure that we are not on a PLL based source before switching */

            /* Write the values before switching. Datasheet says so. */
            PLIB_OSC_SysPLLMultiplierSelect ( OSC_PLIB_ID, valueToPLLMULT );
            PLIB_OSC_SysPLLOutputDivisorSet ( OSC_PLIB_ID, valueToPLLODIV );

            /* Switch to a PLL source */
            PLIB_OSC_SysClockSelect( OSC_PLIB_ID, oscSource );

            delay = SYS_CLK_SYSPLL_LOCK_DELAY_80MHZ;

            /* Wait till the PLL settles down / locked  */
            clkObject.systemClockStatus = SYS_CLK_OPERATION_IN_PROGRESS;

            /* Device expects this delay. We are changing the System clock source here,
            On debugging sometimes the code just stops without this delay. Have to
            understand this further and fine tune this delay. */
//            Nop();
//            Nop();
//            Nop();

            if ( waitUntilComplete == true )
            {
                #if defined (PLIB_OSC_ExistsPLLLockStatus)
                while ( PLIB_OSC_PLLIsLocked ( OSC_PLIB_ID, OSC_PLL_SYSTEM ) != true )
                #endif
                {
                    if ( delay-- <= 0 )
                    {
                    /* Rarest case. Either the PLL lock failed or the bit is showing
                    the wrong status, A restart needed, an error status update will
                    not help */
//                    clkObject.systemClockStatus = SYS_CLK_OPERATION_FAIL_PLL_LOCK_TIMEOUT;

                    //SYS_ASSERT("PLL lock timeout");
//                    Nop();
                    /* Reaching here means clock switching is not enabled
                     through configuration bits */
                    return -1;
                    }
                }
                clkObject.systemClockStatus = SYS_CLK_OPERATION_COMPLETE;
            }
        }
        else
        {
            /* If the new oscillator is not a PLL source, the one we are running on may
            be. So switch first before setting the divisor */
            PLIB_OSC_SysClockSelect( OSC_PLIB_ID, oscSource );

            if ( clockSource == SYS_CLK_SOURCE_FRC_BY_DIV )
            {
                PLIB_OSC_FRCDivisorSelect ( OSC_PLIB_ID, valueToPLLMULT );
            }
        }

        /* Lock it before going back */
        SYS_DEVCON_SystemLock ( );

        /* Return something which is not equal to '-1'. Let us return the clock source
        itself */
        return clockSource;
    }
    return -1;
}


#endif								/* } */

/** Rev string specifically to address the following GCC warning:
 *	"ISO C forbids an empty translation unit [-Wpedantic]"
 */
static char const * const sys_clk_pic32mz_RevString = "$Revision: 0123 $";
